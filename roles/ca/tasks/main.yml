---
# Try to get istio info
- name: Get istio info
  include_tasks: "{{ role_path }}/../../playbooks/get-istio-info.yaml"

- name: Search for the ca node
  community.kubernetes.k8s_info:
    kind: CA
    api_version: operator.fabric.hyperledger.org/v1alpha1
    name: '{{ ansible_operator_meta.name }}'
    namespace: '{{ ansible_operator_meta.namespace }}'
  register: ca_operator

- name: Check if this will be a new operator or an update
  set_fact:
    new_node: "{{ ((ca_operator.resources | length) == 0)| ternary('true', 'false') }}"

- name: Get the home directory
  set_fact:
    workdir: "{{ lookup('env','HOME') }}/vars"
    nodename: "{{ ansible_operator_meta.name }}{{ (domain==None)|ternary('', '.'+domain) }}"

- name: Create canonical name for the node
  set_fact:
    cnodename: "{{ nodename | replace('.', '-') | lower }}"

- name: Create canonical name for the certs and admin secret
  set_fact:
    adminsecretname: "{{ ((admin == None or (admin|trim) == '')) | ternary(cnodename+'-admin', admin) }}"
    cacertsecretname: "{{ ((certs == None or (certs|trim) == '')) | ternary(cnodename+'-certs', certs) }}"

- name: Retrieve the CA admin secret
  community.kubernetes.k8s_info:
    kind: Secret
    api_version: v1
    name: '{{ adminsecretname }}'
    namespace: '{{ ansible_operator_meta.namespace }}'
  register: ca_admin

- name: Generate admin username and pw when there is none
  when: ca_admin.resources | length == 0
  block:
  - debug:
      msg: "Admin secret do not exist, now create basic auth secret"

  - name: Create admin secret
    community.kubernetes.k8s:
      definition:
        kind: Secret
        apiVersion: v1
        metadata:
          name: '{{ adminsecretname }}'
          namespace: '{{ ansible_operator_meta.namespace }}'
        type: kubernetes.io/basic-auth
        stringData:
          username: admin
          password: "{{ lookup('community.general.random_string', length=12, special=false) }}"

- name: Retrieve the CA certificate
  community.kubernetes.k8s_info:
    kind: Secret
    api_version: v1
    name: '{{ cacertsecretname }}'
    namespace: '{{ ansible_operator_meta.namespace }}'
  register: ca_certs

- name: Generate certificates when there is none
  when: ca_certs.resources | length == 0
  block:
  - debug:
      msg: "Certs do not exist, now create them"

  - name: Make sure that working directory exists
    file:
      path: "{{ workdir }}/keys"
      state: "directory"
      mode: 0775
  
  - name: Generate a private keys
    community.crypto.openssl_privatekey:
      path: "{{ workdir }}/keys/{{ cnodename }}-{{ item }}-key.pem"
      curve: secp256r1
      type: ECC
    with_items:
    - "ca"
    - "tls"
  
  - name: Generate an Certificate Signing Request
    community.crypto.openssl_csr:
      path: "{{ workdir }}/keys/{{ cnodename }}-{{ item }}.csr"
      privatekey_path: "{{ workdir }}/keys/{{ cnodename }}-{{ item }}-key.pem"
      subject:
        C: US
        ST: "North Carolina"
        L: "Raleigh"
        O: "{{ domain }}"
      subject_alt_name: "DNS:{{ nodename }}{{ (domain==None)|ternary('', ',DNS:'+domain) }}"
      common_name: "{{ nodename }}"
      basic_constraints_critical: yes
      basic_constraints: 
      - 'CA:TRUE'
      key_usage:
      - digitalSignature
      - keyEncipherment
      - keyCertSign
      - cRLSign
      key_usage_critical: yes
      extended_key_usage:
      - clientAuth
      - serverAuth
      extended_key_usage_critical: yes
    with_items:
    - "ca"
    - "tls"
  
  - name: Generate a certificate based on CSR
    community.crypto.x509_certificate:
      path: "{{ workdir }}/keys/{{ cnodename }}-{{ item }}-cert.pem"
      privatekey_path: "{{ workdir }}/keys/{{ cnodename }}-{{ item }}-key.pem"
      csr_path: "{{ workdir }}/keys/{{ cnodename }}-{{ item }}.csr"
      provider: selfsigned
    with_items:
    - "ca"
    - "tls"
  
  - name: Create a secret
    community.kubernetes.k8s:
      definition:
        kind: Secret
        apiVersion: v1
        metadata:
          name: '{{ cacertsecretname }}'
          namespace: '{{ ansible_operator_meta.namespace }}'
        type: Opaque
        data:
          ca-cert.pem: "{{ lookup('file', workdir+'/keys/'+cnodename+'-ca-cert.pem', errors='ignore') | b64encode }}"
          ca-key.pem: "{{ lookup('file', workdir+'/keys/'+cnodename+'-ca-key.pem', errors='ignore') | b64encode }}"
          tls-cert.pem: "{{ lookup('file', workdir+'/keys/'+cnodename+'-tls-cert.pem', errors='ignore') | b64encode }}"
          tls-key.pem: "{{ lookup('file', workdir+'/keys/'+cnodename+'-tls-key.pem', errors='ignore') | b64encode }}"

- name: start ca service
  community.kubernetes.k8s:
    definition:
      kind: Service
      apiVersion: v1
      metadata:
        labels:
          k8s-app: '{{ cnodename }}'
        name: '{{ ansible_operator_meta.name }}'
        namespace: '{{ ansible_operator_meta.namespace }}'
      spec:
        selector:
          k8s-app: '{{ cnodename }}'
        ports:
        - name: caport
          port: 7054
          targetPort: 7054

- name: start ca node
  community.kubernetes.k8s:
    definition:
      kind: StatefulSet
      apiVersion: apps/v1
      metadata:
        name: '{{ ansible_operator_meta.name }}'
        namespace: '{{ ansible_operator_meta.namespace }}'
      spec:
        selector:
          matchLabels:
            k8s-app: '{{ cnodename }}'
            hlf-type: ca
            hlf-dn: '{{ domain }}'
            hlf-mspid: '{{ cnodename }}'
        serviceName: '{{ ansible_operator_meta.name }}'
        replicas: 1
        volumeClaimTemplates:
        - metadata:
            name: '{{ cnodename }}-data'
          spec:
            accessModes:
            - ReadWriteOnce
            resources:
              requests:
                storage: 2Gi
        template:
          metadata:
            labels:
              k8s-app: '{{ cnodename }}'
              hlf-type: ca
              hlf-dn: '{{ domain }}'
              hlf-mspid: '{{ cnodename }}'
          spec:
            volumes:
            - name: cert-key-id
              secret:
                secretName: '{{ cacertsecretname }}'
            containers:
            - name: fabric-ca
              image: hyperledger/fabric-ca:1.5
              imagePullPolicy: IfNotPresent
              env:
              - { name: "FABRIC_CA_HOME", value: "/etc/hyperledger/fabric-ca-server" }
              - { name: "FABRIC_CA_SERVER_CA_NAME", value: "{{ nodename}}" }
              - { name: "FABRIC_CA_SERVER_CA_KEYFILE", value: "/etc/hyperledger/fabric-ca/idcerts/ca-key.pem" }
              - { name: "FABRIC_CA_SERVER_CA_CERTFILE", value: "/etc/hyperledger/fabric-ca/idcerts/ca-cert.pem" }
              - { name: "FABRIC_CA_SERVER_TLS_ENABLED", value: "true" }
              - { name: "FABRIC_CA_SERVER_TLS_KEYFILE", value: "/etc/hyperledger/fabric-ca/idcerts/tls-key.pem" }
              - { name: "FABRIC_CA_SERVER_TLS_CERTFILE", value: "/etc/hyperledger/fabric-ca/idcerts/tls-cert.pem" }
              - name: CA_USERNAME
                valueFrom:
                  secretKeyRef:
                    name: '{{ adminsecretname }}'
                    key: username
              - name: CA_PASSWORD
                valueFrom:
                  secretKeyRef:
                    name: '{{ adminsecretname }}'
                    key: password
              volumeMounts:
              - { mountPath: "/etc/hyperledger/fabric-ca/idcerts", name: "cert-key-id" }
              - { mountPath: "/etc/hyperledger/fabric-ca-server", name: "{{ cnodename }}-data" }
              command: ["fabric-ca-server"]
              args:  ["start", "-b", "$(CA_USERNAME):$(CA_PASSWORD)", "-d"]

# - name: Wait till the CA is running
#   community.kubernetes.k8s_info:
#     kind: CA
#     api_version: operator.fabric.hyperledger.org/v1alpha1
#     wait: yes
#     name: "{{ ansible_operator_meta.name }}"
#     namespace: "{{ ansible_operator_meta.namespace }}"
#     wait_condition:
#       type: Running
#       reason: Successful
#     wait_sleep: 5
#     wait_timeout: 360
#   register: web_service

# Here we figure out how to expose the node endpoint

# The following tasks are all for exposing the node endpoint to
# outside of the k8s cluster using istio
# When include another playbook, only role_path can be used
# both playbook_dir and inventory_dir will be mapped to tmp directory 

- name: Add a new istio port to istio ingress gateway
  include_tasks: "{{ role_path }}/../../playbooks/add-istio-port.yaml"

- name: Add gateway and virtual service
  include_tasks: "{{ role_path }}/../../playbooks/add-gw-vs.yaml"

# Update the crd to have endpoints and other possible information 
- name: update the crd status
  operator_sdk.util.k8s_status:
    api_version: operator.fabric.hyperledger.org/v1alpha1
    kind: CA
    name: "{{ ansible_operator_meta.name }}"
    namespace: "{{ ansible_operator_meta.namespace }}"
    status:
      endpoint: '{{ domain }}:{{ ext_port}}'